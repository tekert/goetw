package mofgen

import (
	"regexp"
	"strings"
	"text/template"
)

type Parser struct {
	version       string
	outputClasses []*mofParsedClass
	classMap      map[string]*mofParsedClass
}

func NewParser() *Parser {
	return &Parser{
		outputClasses: make([]*mofParsedClass, 0),
		classMap:      make(map[string]*mofParsedClass),
	}
}

// Parse parses MOF content and generates Go code
func Parse(content string) (string, error) {
	p := NewParser()
	p.parseVersion(content)

	// Parse all class definitions
	if err := p.parseClasses(content); err != nil {
		return "", err
	}

	return p.generateCode()
}

// parseClasses scans the MOF content for class definitions and processes them.
// It performs a two-phase parsing:
//  1. First pass: Extract and parse all class definitions using regex
//     Format: [dynamic:ToInstance] class Name : Base { Properties }
//  2. Second pass: Process inheritance chain to resolve:
//     - GUIDs inheritance
//     - Version inheritance
//     - Event type combinations
//
// Returns error if parsing fails, nil otherwise.
func (p *Parser) parseClasses(content string) error {
	classRegex := regexp.MustCompile(`\[\s*dynamic:ToInstance([^\]]*?)\]\s*class\s+(\w+)(?:\s*:\s*(\w+))?\s*{([^}]*?)};`)
	matches := classRegex.FindAllStringSubmatch(content, -1)

	// Parse in order of appearance in MOF file
	for _, match := range matches {
		class := parseClass(match)
		if class != nil {
			p.outputClasses = append(p.outputClasses, class) // for ordered output
			p.classMap[class.Name] = class                   // for fast lookup
		}
	}

	// Process inheritance after parsing all classes
	// Note: Some base classes (like MSNT_SystemTrace) won't be in p.classMap
	// as they are built-in ETW classes
	for _, class := range p.outputClasses {
		if class.Base != "" {
			// Only process inheritance if base class is found in our parsed classes
			if baseClass, ok := p.classMap[class.Base]; ok {
				class.processInheritance(baseClass)
			}
			// Skip inheritance for built-in base classes - class keeps its own GUID/Version
		}
	}

	return nil
}

func (p *Parser) parseVersion(content string) {
	re := regexp.MustCompile(`(?m)^// Version:\s*(.+)$`)
	if m := re.FindStringSubmatch(content); len(m) > 1 {
		p.version = m[1]
	}
}

// codeTemplate defines the Go code structure generated for each MOF class.
// The template generates ETW class definitions in the format:
//
//	var {{.Name}} = &MofClassDef{
//	    Name: "{{.Name}}",                    // Class name (e.g. "Process_V2")
//	    Base: "{{.Base}}",                    // Base class (e.g. "MSNT_SystemTrace")
//	    GUID: {{if .InheritsGUID}}           // Class GUID handling:
//	        {{.Base}}.GUID,                   // - Inherit from base class
//	    {{else}}
//	        *MustParseGUID("{{.GUID}}"),     // - Or use explicit GUID
//	    {{end}}
//	    Version: {{if .InheritsVersion}}      // Version handling:
//	        {{.Base}}.Version,                // - Inherit from base class
//	    {{else}}
//	        {{.Version}},                     // - Or use explicit version
//	    {{end}}
//	    EventTypes: []uint8{ {{.EventTypes}} }, // Event type IDs
//	    Properties: []MofPropertyDef{         // Property definitions:
//	        {ID: {{.ID}},                     // - Property ID
//	         Name: "{{.Name}}",               // - Property name
//	         InType: {{.InType}},             // - Input type (TDH_INTYPE_*)
//	         OutType: {{.OutType}},           // - Output type (TDH_OUTTYPE_*)
//	         IsArray: {{.IsArray}},           // - Array flag
//	         ArraySize: {{.ArraySize}},       // - Fixed array size
//	         SizeFromID: {{.SizeFromID}}},    // - Dynamic array size from property
//	    },
//	}
const codeTemplate = `//go:build windows
// +build windows

package etw

// Code generated by mof parser; DO NOT EDIT.
// Source: WindowsKernelTrace.mof
{{if .Version}}// Version: {{.Version}}{{end}}

{{range .Classes}}
{{- /* Split MOF definition into lines and comment each one */}}
{{- range $line := splitAndComment .MofDefinition}}
{{$line}}
{{- end}}
// {{.Name}} class definition
var {{.Name}} = &MofClassDef{
    Name: "{{.Name}}",
    {{- if .Base}}
    Base: "{{.Base}}",{{end}}
    {{- if not .InheritsGUID}}
    GUID: *MustParseGUID("{{.GUID}}"),
    {{- else}}
    GUID: {{.Base}}.GUID,
    {{- end}}
    {{- if not .InheritsVersion}}
    Version: {{.Version}},
    {{- else}}
    Version: {{.Base}}.Version,
    {{- end}}
    {{- if .EventTypes}}
    EventTypes: []uint8{ {{.EventTypes}} },{{end}}
    {{- if .Properties}}
    Properties: []MofPropertyDef{
        {{- range .Properties}}
        {ID: {{.ID}}, Name: "{{.Name}}", InType: {{.InType}}{{if .OutType}}, OutType: {{.OutType}}{{end}}{{if .IsArray}}, IsArray: {{.IsArray}}{{end}}{{if .ArraySize}}, ArraySize: {{.ArraySize}}{{end}}{{if .SizeFromID}}, SizeFromID: {{.SizeFromID}}{{end}}},
        {{- end}}
    },{{end}}
}
{{end}}

func init() {
    mofClasses := GlobalMofRegistry
    {{- range .Classes}}
    mofClasses.Register({{.Name}})
    {{- end}}
}`

var funcMap = template.FuncMap{
	"splitAndComment": func(s string) []string {
		lines := strings.Split(s, "\n")
		for i, line := range lines {
			lines[i] = "// " + line
		}
		return lines
	},
}

// generateCode executes the code template with parsed MOF data to generate Go source.
// Uses p.outputClasses (ordered slice) rather than p.classMap to maintain consistent
// output ordering. Template data includes:
//   - Classes: Ordered list of parsed MOF classes with their properties
//   - Version: MOF version number
func (p *Parser) generateCode() (string, error) {

	// Generate Go code from template
	tmpl := template.Must(template.New("code").Funcs(funcMap).Parse(codeTemplate))

	// Execute template with parsed data
	var buf strings.Builder
	err := tmpl.Execute(&buf, map[string]interface{}{
		"Classes": p.outputClasses, // Use ordered slice instead of map
		"Version": p.version,
	})
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}
