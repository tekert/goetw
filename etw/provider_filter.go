//go:build windows

package etw

import (
	"strings"
	"syscall"
	"unsafe"
)

// ProviderFilter is an interface for various ETW filters that can be applied when enabling a provider.
//
// These filters are typically applied by the ETW runtime *after* an event has been
// generated by its provider. This is in contrast to Level/Keyword filtering, which
// happens inside the provider *before* an event is generated.
//
// Consequently, using these filters is effective for reducing the volume of data
// in a trace, but it does not reduce the initial CPU overhead of event creation.
//
// Example usage:
//	Filters: []etw.ProviderFilter{
//		etw.NewEventIDFilter(true, 10, 11),
//		//etw.NewPIDFilter(1234, 5678),                             // read doc about limitations
//		//etw.NewExecutableNameFilter("svchost.exe","conhost.exe"), // read doc about limitations
//	},
type ProviderFilter interface {
	// build allocates the necessary C structures and returns a descriptor.
	build() (desc EventFilterDescriptor, keepAlive any)
}

// --- Concrete Filter Implementations ---

// EventIDFilter filters events based on their 16-bit event ID.
//
// # CPU Performance Impact: Medium
//
// This is an "attribute filter" that is applied by the ETW runtime *after* the
// provider has already generated the event and sent it to ETW. This means the
// CPU cost of creating the event has already been paid.
//
// This type of filtering is effective for reducing the volume of trace data
// written to the session buffers, but it is not effective for reducing the
// initial CPU overhead of event generation on the provider side.
//
// When applied to a TraceLogging provider, this filter will be ignored as
// TraceLogging events do not have static event IDs.
//
// The maximum number of event IDs allowed is limited by MAX_EVENT_FILTER_EVENT_ID_COUNT (64).
type EventIDFilter struct {
	IDs      []uint16
	FilterIn bool // True (default) to include these IDs, false to exclude them.
}

// NewEventIDFilter creates a new filter for the given event IDs.
// `filterIn` determines whether to include (true) or exclude (false) events with these IDs.
func NewEventIDFilter(filterIn bool, ids ...uint16) *EventIDFilter {
	return &EventIDFilter{IDs: ids, FilterIn: filterIn}
}

func (f *EventIDFilter) build() (EventFilterDescriptor, any) {
	if len(f.IDs) == 0 || len(f.IDs) > MAX_EVENT_FILTER_EVENT_ID_COUNT {
		return EventFilterDescriptor{}, nil
	}

	// keepAlive holds a reference to the allocated go memory so that uintptr cast survives
	filterData, keepAlive := AllocEventFilterEventID(f.IDs)
	if f.FilterIn {
		filterData.FilterIn = 1
	}

	return EventFilterDescriptor{
		Ptr:  uint64(uintptr(unsafe.Pointer(filterData))),
		Size: uint32(filterData.Size()),
		Type: EVENT_FILTER_TYPE_EVENT_ID,
	}, keepAlive // Pass the keeapalive pointer up to the caller.
}

// PIDFilter filters events based on the Process ID (PID) of the originating process.
//
// # CPU Performance Impact: Low
//
// This is a "scope filter" and is highly efficient. According to Microsoft's
// documentation, providers disabled by scope filters have "almost no impact on
// system performance". This is because the ETW runtime can prevent the provider
// from being enabled within the specified processes altogether, avoiding the CPU
// cost of event generation from those processes entirely.
//
// # Kernel Provider Limitation
//
// This has a critical implication for Kernel Providers (e.g., "Microsoft-Windows-Kernel-Process"):
// The provider is the kernel itself (PID 4 or 0). When a PID filter for a user-mode
// process is applied to a kernel provider, the ETW subsystem appears to IGNORE the
// filter. Events will still be received from the provider as if no PID filter was applied.
//
// The maximum number of PIDs that can be filtered is limited by MAX_EVENT_FILTER_PID_COUNT (8).
type PIDFilter struct {
	PIDs []uint32
}

// NewPIDFilter creates a new filter for the given process IDs. A maximum of 8 PIDs can be supplied.
func NewPIDFilter(pids ...uint32) *PIDFilter {
	return &PIDFilter{PIDs: pids}
}

func (f *PIDFilter) build() (EventFilterDescriptor, any) {
	const maxPIDs = 8 // MAX_EVENT_FILTER_PID_COUNT
	if len(f.PIDs) == 0 || len(f.PIDs) > maxPIDs {
		return EventFilterDescriptor{}, nil
	}

	// Create a copy that is kept alive.
	pidCopy := make([]uint32, len(f.PIDs))
	copy(pidCopy, f.PIDs)

	desc := EventFilterDescriptor{
		Ptr:  uint64(uintptr(unsafe.Pointer(&pidCopy[0]))),
		Size: uint32(len(pidCopy) * 4),
		Type: EVENT_FILTER_TYPE_PID,
	}

	// Return a pointer to the original slice. This is the simplest and safest object to keep alive.
	return desc, &pidCopy
}

// ExecutableNameFilter filters events based on the file name of the originating process.
//
// # CPU Performance Impact: Low
//
// This is a "scope filter" and is highly efficient for the same reasons as the
// PIDFilter. It can prevent a provider from being enabled within processes matching
// the given executable names, which avoids the CPU cost of event generation.
//
// # Kernel Provider Limitation
//
// This filter is generally ignored when used with Kernel Providers, similar to the PIDFilter.
//
// The filter is a single string that can contain multiple executable file names
// separated by semicolons (e.g., "svchost.exe;conhost.exe").
type ExecutableNameFilter struct {
	Names []string
}

// NewExecutableNameFilter creates a new filter for the given executable names (e.g., "svchost.exe").
func NewExecutableNameFilter(names ...string) *ExecutableNameFilter {
	return &ExecutableNameFilter{Names: names}
}

func (f *ExecutableNameFilter) build() (EventFilterDescriptor, any) {
	if len(f.Names) == 0 {
		return EventFilterDescriptor{}, nil
	}

	joined := strings.Join(f.Names, ";")
	// The API expects a null-terminated wide string (UTF-16).
	utf16Str, err := syscall.UTF16FromString(joined)
	if err != nil {
		return EventFilterDescriptor{}, nil
	}

	desc := EventFilterDescriptor{
		Ptr:  uint64(uintptr(unsafe.Pointer(&utf16Str[0]))),
		Size: uint32(len(utf16Str) * 2), // size in bytes, including null terminator
		Type: EVENT_FILTER_TYPE_EXECUTABLE_NAME,
	}
	//cleanup := func() { _ = utf16Str }

	return desc, &utf16Str
}
