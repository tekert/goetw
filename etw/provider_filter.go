//go:build windows

package etw

import (
	"strings"
	"syscall"
	"unsafe"
)

// ProviderFilter is an interface for various ETW filters that can be applied when enabling a provider.
//
// These filters are typically applied by the ETW runtime *after* an event has been
// generated by its provider. This is in contrast to Level/Keyword filtering, which
// happens inside the provider *before* an event is generated.
//
// Consequently, using these filters is effective for reducing the volume of data
// in a trace, but it does not reduce the initial CPU overhead of event creation.
type ProviderFilter interface {
	// build allocates the necessary C structures and returns a descriptor.
	build() (desc EventFilterDescriptor, cleanup func())
}

// --- Concrete Filter Implementations ---

// EventIDFilter filters events based on their 16-bit event ID.
//
// NOTE: This is a "runtime-side" filter. The provider generates the event, and the
// ETW runtime checks its ID against this filter before sending it to the session.
// The overhead of event creation has already occurred, but this can reduce trace volume.
type EventIDFilter struct {
	IDs      []uint16
	FilterIn bool // True (default) to include these IDs, false to exclude them.
}

// NewEventIDFilter creates a new filter for the given event IDs.
// `filterIn` determines whether to include (true) or exclude (false) events with these IDs.
func NewEventIDFilter(filterIn bool, ids ...uint16) *EventIDFilter {
	return &EventIDFilter{IDs: ids, FilterIn: filterIn}
}

func (f *EventIDFilter) build() (EventFilterDescriptor, func()) {
	if len(f.IDs) == 0 || len(f.IDs) > MAX_EVENT_FILTER_EVENT_ID_COUNT {
		return EventFilterDescriptor{}, nil
	}

	filterData := AllocEventFilterEventID(f.IDs)
	if f.FilterIn {
		filterData.FilterIn = 1
	}

	return EventFilterDescriptor{
		Ptr:  uint64(uintptr(unsafe.Pointer(filterData))),
		Size: uint32(filterData.Size()),
		Type: EVENT_FILTER_TYPE_EVENT_ID,
	}, nil
}

// PIDFilter filters events based on the Process ID (PID) of the originating process.
//
// NOTE: This is a "scope filter". It is highly efficient because it can prevent a
// provider from being enabled within a process altogether, eliminating all event
// generation overhead from that process.
//
// This has a critical implication for Kernel Providers (e.g., "Microsoft-Windows-Kernel-Process"):
// The provider is the kernel itself (PID 4 or 0). When a PID filter for a user-mode
// process is applied to a kernel provider, the ETW subsystem appears to IGNORE the
// filter rather than blocking events. Events will still be received from the provider
// as if no PID filter was applied.
type PIDFilter struct {
	PIDs []uint32
}

// NewPIDFilter creates a new filter for the given process IDs. A maximum of 8 PIDs can be supplied.
func NewPIDFilter(pids ...uint32) *PIDFilter {
	return &PIDFilter{PIDs: pids}
}

func (f *PIDFilter) build() (EventFilterDescriptor, func()) {
	const maxPIDs = 8 // MAX_EVENT_FILTER_PID_COUNT
	if len(f.PIDs) == 0 || len(f.PIDs) > maxPIDs {
		return EventFilterDescriptor{}, nil
	}

	// Create a copy to ensure the data is stable during the C call.
	pidCopy := make([]uint32, len(f.PIDs))
	copy(pidCopy, f.PIDs)

	return EventFilterDescriptor{
		Ptr:  uint64(uintptr(unsafe.Pointer(&pidCopy[0]))),
		Size: uint32(len(pidCopy) * 4),
		Type: EVENT_FILTER_TYPE_PID,
	}, nil
}

// ExecutableNameFilter filters events based on the file name of the originating process.
//
// NOTE: This is a "scope filter" and has the same behavior and limitations as the
// PIDFilter. It is highly efficient for user-mode providers but is generally ignored
// when used with Kernel Providers.
type ExecutableNameFilter struct {
	Names []string
}

// NewExecutableNameFilter creates a new filter for the given executable names (e.g., "svchost.exe").
func NewExecutableNameFilter(names ...string) *ExecutableNameFilter {
	return &ExecutableNameFilter{Names: names}
}

func (f *ExecutableNameFilter) build() (EventFilterDescriptor, func()) {
	if len(f.Names) == 0 {
		return EventFilterDescriptor{}, nil
	}

	joined := strings.Join(f.Names, ";")
	// The API expects a null-terminated wide string (UTF-16).
	utf16Str, err := syscall.UTF16FromString(joined)
	if err != nil {
		return EventFilterDescriptor{}, nil
	}

	return EventFilterDescriptor{
		Ptr:  uint64(uintptr(unsafe.Pointer(&utf16Str[0]))),
		Size: uint32(len(utf16Str) * 2), // size in bytes, including null terminator
		Type: EVENT_FILTER_TYPE_EXECUTABLE_NAME,
	}, nil
}
