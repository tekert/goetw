//go:build windows

package etw

// Important documentation "hidden" in the Remarks section:
// It's about almost everything session and provider related.
// https://learn.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enabletraceex2

import (
	"fmt"
	"syscall"
	"unsafe"
)

// Trace Session interface
type Session interface {
	TraceName() string
	Providers() []Provider
	IsKernelSession() bool
}

// Real time Trace Session
type RealTimeSession struct {
	traceProps    *EventTracePropertyData2
	sessionHandle syscall.Handle
	traceName     string

	enabledProviders []Provider
}

func (p *RealTimeSession) IsKernelSession() bool {
	return p.traceName == NtKernelLogger ||
		(p.traceProps.LogFileMode&EVENT_TRACE_SYSTEM_LOGGER_MODE) != 0
}

// NewRealTimeSession creates a new ETW trace session to receive events
// in real time
func NewRealTimeSession(name string) (s *RealTimeSession) {
	s = &RealTimeSession{}
	s.traceProps = NewRealTimeEventTraceProperties(name)
	s.traceName = name
	s.enabledProviders = make([]Provider, 0)
	return
}

// Only use this if the providers that will be enabled are not kernel providers
//
// NewPagedRealTimeSession creates a new ETW trace session to receive events
// in real time that uses paged memory.
// This setting is recommended so that events do not use up the nonpaged memory.
// Nonpaged buffers use nonpaged memory for buffer space.
// Because nonpaged buffers are never paged out, a logging session performs well.
// Using pageable buffers is less resource-intensive.
// Kernel-mode providers and system loggers cannot log events to sessions that specify this logging mode.
func NewPagedRealTimeSession(name string) (s *RealTimeSession) {
	s = NewRealTimeSession(name)
	s.traceProps.LogFileMode |= EVENT_TRACE_USE_PAGED_MEMORY
	return
}

// NewKernelRealTimeSession creates a new ETW trace system session to enable reading from the
// NT Kernel Logger trace events in real time (only one session can be running at any time)
//
// use: [GetKernelProviderFlags] for some predefined flags.
//
// To use a provider, you must enable it in the session creation
// like this:
//
//	kernelSession := etw.NewKernelRealTimeSession(etw.GetKernelProviderFlags("FileIo", "FileIoInit"))
//
// For File rundown events (opcode 36)
//
//	kernelSession := etw.NewKernelRealTimeSession(etw.GetKernelProviderFlags("DiskFileIo"))
//
// or
//
//	kernelSession := etw.NewKernelRealTimeSession(etw.EVENT_TRACE_FLAG_DISK_IO | etw.EVENT_TRACE_FLAG_DISK_FILE_IO)
//
// For a list of kernel providers use:
//
//	 for _, pd := range etw.KernelProviders {
//		 fmt.Printf("\t%s: %s\n", pd.Name, pd.GUID)
//	 }
//
// EnableFlags: https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties EnableFlags section
//
// NOTE:
// These are legacy MOF type events. (without a manifest some of these event don't parse well)
// Most of the events properties that track something may have a zero value. (kernel memory)
//
// Some MOF are not documented on the microsoft site, for example: Process_V4_TypeGroup1 etc..
//
// https://msdn.microsoft.com/en-us/library/windows/desktop/aa364083(v=vs.85).aspx
func NewKernelRealTimeSession(flags ...uint32) (p *RealTimeSession) {
	p = NewRealTimeSession(NtKernelLogger)
	// guid must be set for Kernel Session
	p.traceProps.Wnode.Guid = *systemTraceControlGuid
	for _, flag := range flags {
		p.traceProps.EnableFlags |= flag
	}
	return
}

// Windows 11-only.
//
// New way to enable kernel (now system) providers
// The events generated by the System Trace Provider are not changing due to this new feature.
// This means that the events are not marked as being emitted from the individual
// system providers.
//
// https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-a-systemtraceprovider-session
//
// # Starting a SystemTraceProvider Session using guids and keywords
//
// How to use it:
//   - GUIDs and Keywords defined here: https://learn.microsoft.com/en-us/windows/win32/etw/system-providers
//   - Write the keywords you want and put them in ParseProvider() wich are then passed to EnableTraceEx2
//
// Use the provider names in MustParseProvider()
// get the names using:  logman query providers | findstr -i system
//
// OR
//
//		var prov etw.Provider
//	 prov.GUID = etw.SystemProcessProviderGuid
//	 prov.EnableLevel = 0xff // any level
//	 prov.MatchAnyKeyword = etw.SYSTEM_PROCESS_KW_GENERAL
//	 prov.MatchAllKeyword = 0
//	 if err := s.EnableProvider(prov); err != nil {
//		 panic(err)
//	 }
func NewSystemTraceProviderSession(name string) (s *RealTimeSession) {
	s = NewRealTimeSession(name)
	s.traceProps.LogFileMode |= EVENT_TRACE_SYSTEM_LOGGER_MODE
	return
}

// TODO: remove logSessionName param, no longer used.
func NewRealTimeEventTraceProperties(logSessionName string) *EventTracePropertyData2 {
	traceProps, size := NewEventTracePropertiesV2()

	// https://learn.microsoft.com/en-us/windows/win32/etw/wnode-header
	// Necessary fields for SessionProperties struct
	traceProps.Wnode.BufferSize = size // this is optimized by ETWframework
	traceProps.Wnode.Guid = GUID{}     // Will be set by etw
	// Only used if PROCESS_TRACE_MODE_RAW_TIMESTAMP is set in the Consumer side
	traceProps.Wnode.ClientContext = 1 // QPC
	// *NOTE(tekert) should this be WNODE_FLAG_TRACED_GUID instead of WNODE_FLAG_ALL_DATA?
	// WNODE_FLAG_VERSIONED_PROPERTIES means use EventTraceProperties2
	traceProps.Wnode.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_VERSIONED_PROPERTIES
	traceProps.LogFileMode = EVENT_TRACE_REAL_TIME_MODE
	traceProps.LogFileNameOffset = 0
	//* ETW event can be up to 64KB size so if the buffer size is not at least
	// big enough to contain such an event, the event will be lost
	// source: https://docs.microsoft.com/en-us/message-analyzer/specifying-advanced-etw-session-configuration-settings
	traceProps.BufferSize = 64

	// StartTrace will copy the string for us.
	traceProps.LoggerNameOffset = traceProps.GetTraceNameOffset()

	return traceProps
}

// IsStarted returns true if the session is already started
func (s *RealTimeSession) IsStarted() bool {
	return s.sessionHandle != 0
}

// Start setups our session buffers so that providers can write to it
func (s *RealTimeSession) Start() (err error) {
	if s.IsStarted() {
		return
	}

	var u16TraceName *uint16
	if u16TraceName, err = syscall.UTF16PtrFromString(s.traceName); err != nil {
		return err
	}

	if s.IsKernelSession() {
		// Remove EVENT_TRACE_USE_PAGED_MEMORY flag from session properties
		s.traceProps.LogFileMode &= ^uint32(EVENT_TRACE_USE_PAGED_MEMORY)
	}

	traceProps := &s.traceProps.EventTraceProperties2
	if err = StartTrace(&s.sessionHandle, u16TraceName, traceProps); err != nil {
		// we handle the case where the trace already exists
		if err == ERROR_ALREADY_EXISTS {
			// we have to use a copy of properties as ControlTrace modifies
			// the structure and if we don't do that we cannot StartTrace later
			// the contigous memory space is not needed for this operation
			propCopy := *traceProps
			// we close the trace first
			ControlTrace(0, u16TraceName, &propCopy, EVENT_TRACE_CONTROL_STOP)
			return StartTrace(&s.sessionHandle, u16TraceName, traceProps)
		}
		return
	}

	return
}

// EnableProvider enables the trace session to receive events from a given provider
// using the configuration options specified within the Provider struct.
//
// Performance Note: Filtering events via the provider's Level and Keywords is the
// most efficient method, as it prevents the provider from generating disabled events
// in the first place. Other filter types (e.g., EventIDFilter) are applied by the
// ETW runtime after the event has been generated (depends on provider), which reduces
// trace volume but not the initial CPU overhead of generation.
func (s *RealTimeSession) EnableProvider(prov Provider) (err error) {
    // If the trace is not started yet we have to start it
    // otherwise we cannot enable provider
	if !s.IsStarted() {
		if err = s.Start(); err != nil {
			return
		}
	}

	var descriptors []EventFilterDescriptor
	// The data backing the pointers in the descriptors is managed by Go's GC.
	// It will be kept alive on the stack/heap during the synchronous EnableTraceEx2 call.
	for _, f := range prov.Filters {
		desc, _ := f.build() // cleanup is not needed for these simple filter types
		if desc.Type != EVENT_FILTER_TYPE_NONE {
			descriptors = append(descriptors, desc)
		}
	}

	params := EnableTraceParameters{
		Version: 2,

		// Does not seem to bring valuable information
		//EnableProperty: EVENT_ENABLE_PROPERTY_PROCESS_START_KEY,
	}

	if len(descriptors) > 0 {
		params.EnableFilterDesc = (*EventFilterDescriptor)(unsafe.Pointer(&descriptors[0]))
		params.FilterDescCount = uint32(len(descriptors))
	}

	if err = EnableTraceEx2(
		s.sessionHandle,
		&prov.GUID,
		EVENT_CONTROL_CODE_ENABLE_PROVIDER,
		prov.EnableLevel,
		prov.MatchAnyKeyword,
		prov.MatchAllKeyword,
		0,
		&params,
	); err != nil {
		return fmt.Errorf("EnableTraceEx2 failed for provider %s (%s): %w", prov.Name, prov.GUID.String(), err)
	}

	s.enabledProviders = append(s.enabledProviders, prov)

	return
}

// DisableProvider disables the trace session from receiving events from a given provider.
func (s *RealTimeSession) DisableProvider(prov Provider) (err error) {
	if !s.IsStarted() {
		// Can't disable a provider on a session that isn't running.
		return nil
	}

	if err = EnableTraceEx2(
		s.sessionHandle,
		&prov.GUID,
		EVENT_CONTROL_CODE_DISABLE_PROVIDER,
		0, // Level, Keywords, etc. are ignored for disable.
		0,
		0,
		0,
		nil,
	); err != nil {
		return
	}

	// Remove from the active provider list.
	newEnabled := s.enabledProviders[:0]
	for _, p := range s.enabledProviders {
		if !p.GUID.Equals(&prov.GUID) {
			newEnabled = append(newEnabled, p)
		}
	}
	s.enabledProviders = newEnabled

	return
}

// GetRundownEvents forces rundown events now on this session.
// a null provider will force rundown for all providers in the session
func (s *RealTimeSession) GetRundownEvents(guid *GUID) (err error) {
	if !s.IsStarted() {
		return fmt.Errorf("session not started")
	}
	if guid != nil {
		return EnableTraceEx2(
			s.sessionHandle,
			guid,
			EVENT_CONTROL_CODE_CAPTURE_STATE,
			0, 0, 0, 0, nil)
	} else {
		for _, p := range s.enabledProviders {
			// If the provider is not enabled, we cannot get rundown events
			if p.EnableLevel == 0 {
				continue
			}

			if err = EnableTraceEx2(
				s.sessionHandle,
				&p.GUID,
				EVENT_CONTROL_CODE_CAPTURE_STATE,
				0, 0, 0, 0, nil); err != nil {
				return
			}
		}
	}

	return nil
}

// TraceName implements Session interface
func (s *RealTimeSession) TraceName() string {
	return s.traceName
}

// Providers implements Session interface
func (s *RealTimeSession) Providers() []Provider {
	// Return a copy to prevent modification of the internal slice.
	providers := make([]Provider, len(s.enabledProviders))
	copy(providers, s.enabledProviders)
	return providers
}

// Stop stops the session. It first attempts to disable all enabled providers
// and then blocks until all buffers are flushed and the session is fully stopped.
func (s *RealTimeSession) Stop() error {
	// It's best practice to disable providers before stopping the session.
	for _, p := range s.enabledProviders {
		// We can ignore errors here, as we're stopping the session anyway.
		_ = s.DisableProvider(p)
	}

	s.enabledProviders = nil // Clear the slice

	return ControlTrace(s.sessionHandle, nil, &s.traceProps.EventTraceProperties2,
		EVENT_TRACE_CONTROL_STOP)
}

// Gets a copy of the current EventTraceProperties file used for this session
func (s *RealTimeSession) GetTracePropertyCopy() *EventTracePropertyData2 {
	return s.traceProps.Clone()
}

// Queries the current trace session to get updated trace properties and stats.
// This is the "controller's view" of the session, using the session handle
// obtained when Start() was called. It is the most direct way to query a session
// that this process has created and is actively managing.
//
// The returned pointer refers to the session's internal properties struct and should
// not be modified.
func (s *RealTimeSession) QueryTrace() (prop *EventTracePropertyData2, err error) {
	// If you are reusing a EVENT_TRACE_PROPERTIES structure
	// (i.e. using a structure that you previously passed to StartTrace or ControlTrace),
	// be sure to set the LogFileNameOffset member to 0 unless you are changing the log file name.
	s.traceProps.LogFileNameOffset = 0
	if err := ControlTrace(s.sessionHandle, nil, &s.traceProps.EventTraceProperties2,
		EVENT_TRACE_CONTROL_QUERY); err != nil {
		return nil, err
	}
	return s.traceProps, nil
}

// Flushes the session's active buffers.
// This will block until all buffers are flushed and the session is fully stopped
// If the session is not started, it returns an error.
func (s *RealTimeSession) Flush() error {
	if s.sessionHandle == 0 {
		return fmt.Errorf("session not started")
	}

	return ControlTrace(s.sessionHandle, nil, &s.traceProps.EventTraceProperties2,
		EVENT_TRACE_CONTROL_FLUSH)
}

// Provide a valid trace name
// This returns a wrapper for the [EventTraceProperties2] struct that accounts for
// the strings space after the struct.
func NewQueryTraceProperties(traceName string) *EventTracePropertyData2 {
	traceProps, size := NewEventTracePropertiesV2()
	// Set only required fields for QUERY
	traceProps.Wnode.BufferSize = size
	traceProps.Wnode.Guid = GUID{}
	traceProps.SetTraceName(traceName)
	traceProps.LoggerNameOffset = traceProps.GetTraceNameOffset()
	traceProps.LogFileNameOffset = 0

	if traceProps.Wnode.BufferSize < traceProps.LoggerNameOffset+uint32(len(traceProps.LoggerName)*2) {
		panic("Not enough buffer space for LoggerName")
	}
	if traceProps.Wnode.BufferSize < traceProps.LogFileNameOffset+uint32(len(traceProps.LogFileName)*2) {
		panic("Not enough buffer space for LogFileName")
	}

	return traceProps
}

// Gets the properties of a realtime event trace session with instaceName (loggerName or traceName)
// logFileName not suported (sessions that write to a file)
// Use [NewQueryTraceProperties] output as parameter
//
// QueryTrace queries the properties and status of a running trace session by name.
// This is a low-level function that wraps the `ControlTrace` API with the
// `EVENT_TRACE_CONTROL_QUERY` command. It's used to get statistics for any
// running session, even those started by other processes.
//
// The `queryProp` parameter serves as both input and output. It must be a
// non-nil pointer to an `EventTracePropertyData2` struct, typically created
// with `NewQueryTraceProperties`. The `LoggerName` field within this struct
// is used to identify the session to query. On success, the same struct is
// populated with the current properties and statistics of the session.
//
// This function is used internally by `ConsumerTrace.QueryTrace()`.
func QueryTrace(queryProp *EventTracePropertyData2) (err error) {
	if queryProp == nil {
		return fmt.Errorf("data must be non nil")
	}
	instanceName := queryProp.GetTraceName()

	// If you are reusing a EVENT_TRACE_PROPERTIES structure
	// (i.e. using a structure that you previously passed to StartTrace or ControlTrace),
	// be sure to set the LogFileNameOffset member to 0 unless you are changing the log file name.
	queryProp.LogFileNameOffset = 0

	// There is no need to have the loggerName in queryProp.LoggerName
	// ControlTrace will set it for us on return. (instaceName -> quertProp.LoggerNameOffset)
	if err := ControlTrace(
		syscall.Handle(0),
		instanceName,
		&queryProp.EventTraceProperties2,
		EVENT_TRACE_CONTROL_QUERY); err != nil {
		return fmt.Errorf("ControlTrace query failed: %w", err)
	}
	return nil
}

// StopSession stops a trace session by its name. This is useful for cleaning up
// sessions that might have been left running from previous processes.
func StopSession(name string) error {
	prop := NewQueryTraceProperties(name)
	// The session handle is not used when stopping a trace by name.
	const nullTraceHandle = 0
	u16Name, err := syscall.UTF16PtrFromString(name)
	if err != nil {
		return err
	}
	return ControlTrace(nullTraceHandle, u16Name, &prop.EventTraceProperties2, EVENT_TRACE_CONTROL_STOP)
}

// (used for internal debuggging)
func newQueryProperties2(tname string) *EventTracePropertyData2 {
	traceProps, size := NewEventTracePropertiesV2()
	// Set only required fields for QUERY
	traceProps.Wnode.BufferSize = size
	traceProps.Wnode.Guid = GUID{}

	traceProps.SetTraceName(tname)
	traceProps.LoggerNameOffset = traceProps.GetTraceNameOffset()
	traceProps.LogFileNameOffset = 0

	return traceProps
}

// Gets the properties of a trace session pointed by props
// Use a valid properties struct created with [NewQueryTraceProperties]
// The trace name is taken from props.LoggerNameOffset.
// (used for internal debuggging)
func queryTrace2(traceProps *EventTracePropertyData2) (err error) {
	// get loggerName from the props.LoggerNameOffset
	loggerName := traceProps.GetTraceName()

	// There is no need to have the loggerName in the properties
	// but we use for save us another parameter
	if err := ControlTrace(
		syscall.Handle(0),
		loggerName,
		&traceProps.EventTraceProperties2,
		EVENT_TRACE_CONTROL_QUERY); err != nil {
		return fmt.Errorf("ControlTrace query failed: %w", err)
	}
	return nil
}
