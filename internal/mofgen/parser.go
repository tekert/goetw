package mofgen

import (
	"regexp"
	"sort"
	"strings"
	"text/template"
)

type Parser struct {
	version       string
	outputClasses []*mofParsedClass
	classMap      map[string]*mofParsedClass
}

func NewParser() *Parser {
	return &Parser{
		outputClasses: make([]*mofParsedClass, 0),
		classMap:      make(map[string]*mofParsedClass),
	}
}

// Parse parses MOF content and generates Go code
func Parse(content string) (string, error) {
	p := NewParser()
	p.parseVersion(content)

	// Parse all class definitions
	if err := p.parseClasses(content); err != nil {
		return "", err
	}

	return p.generateCode()
}

// parseClasses scans the MOF content for class definitions and processes them.
// It performs a two-phase parsing:
//  1. First pass: Extract and parse all class definitions using regex
//     Format: [dynamic:ToInstance] class Name : Base { Properties }
//  2. Second pass: Process inheritance chain to resolve:
//     - GUIDs inheritance
//     - Version inheritance
//     - Event type combinations
//
// Returns error if parsing fails, nil otherwise.
func (p *Parser) parseClasses(content string) error {
	classRegex := regexp.MustCompile(`(?s)\[\s*dynamic:ToInstance([^\]]*?)\]\s*class\s+(\w+)(?:\s*:\s*(\w+))?\s*{([^}]*?)};`)
	matches := classRegex.FindAllStringSubmatch(content, -1)

	// Parse in order of appearance in MOF file
	for _, match := range matches {
		class := parseClass(match)
		if class != nil {
			p.outputClasses = append(p.outputClasses, class) // for ordered output
			p.classMap[class.Name] = class                   // for fast lookup
		}
	}

	// Process inheritance after parsing all classes
	// Note: Some base classes (like MSNT_SystemTrace) won't be in p.classMap
	// as they are built-in ETW classes
	for _, class := range p.outputClasses {
		if class.Base != "" {
			// Only process inheritance if base class is found in our parsed classes
			if baseClass, ok := p.classMap[class.Base]; ok {
				class.processInheritance(baseClass)
			}
			// Skip inheritance for built-in base classes - class keeps its own GUID/Version
		}
	}

	return nil
}

func (p *Parser) parseVersion(content string) {
	re := regexp.MustCompile(`(?m)^// Version:\s*(.+)$`)
	if m := re.FindStringSubmatch(content); len(m) > 1 {
		p.version = m[1]
	}
}

// codeTemplate defines the Go code structure generated for each MOF class.
const codeTemplate = `//go:build windows
// +build windows

package etw

// Code generated by mof parser; DO NOT EDIT.
// Source: WindowsKernelTrace.mof
{{if .Version}}// Version: {{.Version}}{{end}}

{{range .Classes}}
{{- /* Split MOF definition into lines and comment each one */}}
{{- range $line := splitAndComment .MofDefinition}}
{{$line}}
{{- end}}
// mof{{.Name}} class definition
var mof{{.Name}} = &MofClassDef{
	Name: "{{.Name}}",
	NameW: {{.NameW}},
	{{- if .Base}}
	Base: "{{.Base}}",
	BaseW: {{.BaseW}},{{end}}
	{{- if not .InheritsGUID}}
	GUID: *MustParseGUID("{{.GUID}}"),
	{{- else}}
	GUID: mof{{.Base}}.GUID,
	{{- end}}
	{{- if not .InheritsVersion}}
	Version: {{.Version}},
	{{- else}}
	Version: mof{{.Base}}.Version,
	{{- end}}
	{{- if .EventTypes}}
	EventTypes: []uint8{ {{.EventTypes}} },{{end}}
	{{- if .Properties}}
	Properties: []MofPropertyDef{
		{{- range .Properties}}
		{ID: {{.ID}}, Name: "{{.Name}}", NameW: {{.NameW}}, InType: {{.InType}}
			{{- if .OutType}}, OutType: {{.OutType}}{{- end -}}
			{{- if .IsArray}}, IsArray: {{.IsArray}}{{- end -}}
			{{- if .ArraySize}}, ArraySize: {{.ArraySize}}{{- end -}}
			{{- if .SizeFromID}}, SizeFromID: {{.SizeFromID}}{{- end -}}
		},
		{{- end}}
	},{{end}}
}
{{end}}

// MofClassMapping maps provider GUIDs to class names and base event IDs
var MofClassMapping2 = map[uint32]MofKernelNames{
	{{- range $i, $class := .ClassMapping}}
	guidToUint("{{$class.GUID}}"): {Name: "{{$class.Name}}", BaseId: calcBaseId({{$i}})},
	{{- end}}
}

func init() {
	if !mofKernelClassLoaded {
		{{- range .Classes}}
		MofRegister(mof{{.Name}})
		{{- end}}

		mofKernelClassLoaded = true
	}
}`

var funcMap = template.FuncMap{
	"splitAndComment": func(s string) []string {
		lines := strings.Split(s, "\n")
		for i, line := range lines {
			lines[i] = "// " + line
		}
		return lines
	},
	"privateVar": func(s string) string {
		if len(s) == 0 {
			return s
		}
		return strings.ToLower(s[:1]) + s[1:]
	},
}

// generateCode executes the code template with parsed MOF data to generate Go source.
// Uses p.outputClasses (ordered slice) rather than p.classMap to maintain consistent
// output ordering. Template data includes:
//   - Classes: Ordered list of parsed MOF classes with their properties
//   - Version: MOF version number
func (p *Parser) generateCode() (string, error) {
	// Generate Go code from template
	tmpl := template.Must(template.New("code").Funcs(funcMap).Parse(codeTemplate))

	// Execute template with parsed data
	var buf strings.Builder
	err := tmpl.Execute(&buf, map[string]any{
		"Classes":      p.outputClasses, // Use ordered slice instead of map
		"Version":      p.version,
//		"ClassMapping": p.generateClassMapping(),
	})
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

// NOT USED
// TODO(tekert): It's better to manually manage this for now, we are missing some classes.
func (p *Parser) generateClassMapping() []*mofParsedClass {
	// Use a map to store GUID -> Name mapping
	bclasses := make([]*mofParsedClass, 0)

	// First pass: collect all GUIDs and find base names
	for _, class := range p.outputClasses {
		if class.GUID == "" {
			continue
		}

		// Skip if name contains underscore or if it inherits GUID
		if strings.Contains(class.Name, "_") || class.InheritsGUID {
			continue
		}

		bclasses = append(bclasses, class)
	}

	// Sort alphabetically by name
	sort.Slice(bclasses, func(i, j int) bool {
		return bclasses[i].Name < bclasses[j].Name
	})

	return bclasses
}
