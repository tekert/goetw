import re
import os

# Deprecated script, kept for reference and historical context.

# Parses WindowsKernelTrace.mof file and generates Go code for ETW MOF class definitions
# Replaced by go mofgen, better interopt and future maintenance.

# MOF qualifiers: https://learn.microsoft.com/en-us/windows/win32/etw/event-tracing-mof-qualifiers

# Enhanced type mappings
TYPE_MAP = {
    "uint8": "TDH_INTYPE_UINT8",
    "uint16": "TDH_INTYPE_UINT16",
    "uint32": "TDH_INTYPE_UINT32",
    "uint64": "TDH_INTYPE_UINT64",
    "sint8": "TDH_INTYPE_INT8",
    "sint16": "TDH_INTYPE_INT16",
    "sint32": "TDH_INTYPE_INT32",
    "sint64": "TDH_INTYPE_INT64",
    "pointer": "TDH_INTYPE_POINTER",
    "string": "TDH_INTYPE_UNICODESTRING",
    "object": "TDH_INTYPE_POINTER",
    "char16": "TDH_INTYPE_UNICODECHAR",
    "boolean": "TDH_INTYPE_BOOLEAN",
}

# Format qualifier mappings
FORMAT_MAP = {
    'x': 'TDH_OUTTYPE_HEXINT32',   # Display as hex
    'w': 'TDH_OUTTYPE_STRING',     # Wide string
    'c': 'TDH_OUTTYPE_STRING',     # ASCII character
    's': 'TDH_OUTTYPE_STRING',     # Null-terminated string
}

# Extension qualifier mappings
EXTENSION_MAP = {
    'Port': ('TDH_INTYPE_UINT16', 'TDH_OUTTYPE_PORT'),
    'IPAddrV6': ('TDH_INTYPE_BINARY', 'TDH_OUTTYPE_IPV6'),
    'IPAddrV4': ('TDH_INTYPE_UINT32', 'TDH_OUTTYPE_IPV4'),
    'IPAddr': ('TDH_INTYPE_UINT32', 'TDH_OUTTYPE_IPV4'),    # Legacy alias
    'SizeT': ('TDH_INTYPE_POINTER', 'TDH_OUTTYPE_HEXINT64'),
    'Sid': ('TDH_INTYPE_SID', 'TDH_OUTTYPE_STRING'),
    'GUID': ('TDH_INTYPE_GUID', 'TDH_OUTTYPE_GUID'),
    'WmiTime': ('TDH_INTYPE_UINT64', 'TDH_OUTTYPE_DATETIME'),
    'NoPrint': ('TDH_INTYPE_BINARY', None),
    'RString': ('TDH_INTYPE_ANSISTRING', 'TDH_OUTTYPE_STRING'),
    'RWString': ('TDH_INTYPE_UNICODESTRING', 'TDH_OUTTYPE_STRING'),
    'Variant': ('TDH_INTYPE_BINARY', None),
}

class MofGenerator:
    def __init__(self, input_file, output_file):
        self.input_file = input_file
        self.output_file = output_file
        self.classes = []
        self.version = None

    def parse_version(self, content):
        """Extract version from MOF file header comment"""
        version_match = re.search(r'// Version:\s*(.*?)$', content, re.MULTILINE)
        if version_match:
            self.version = version_match.group(1).strip()

    def write_header(self, f):
        """Write file header with version info"""
        header = f"""//go:build windows
// +build windows

package etw

// Code generated by mof_to_go.py; DO NOT EDIT.
// Source: WindowsKernelTrace.mof
"""
        if self.version:
            header += f"// Version: {self.version}\n"

        header += "\nvar mofClasses *MofClassRegistry\n\n"
        f.write(header)

    def parse_mof(self):
        """Parse MOF file and extract class definitions"""
        with open(self.input_file) as f:
            content = f.read()

        self.parse_version(content)

        # Improved pattern to capture all parts of class definition
        class_pattern = r'\[\s*dynamic:ToInstance([^\]]*?)\]\s*class\s+(\w+)(?:\s*:\s*(\w+))?\s*{([^}]*?)};'

        for match in re.finditer(class_pattern, content, re.DOTALL):
            attributes, name, base, body = match.groups()

            # Parse class attributes
            guid = re.search(r'Guid\s*\(\s*"({[^}]+})"\s*\)', attributes + body)
            version = re.search(r'EventVersion\s*\(\s*(\d+)\s*\)', attributes + body)
            event_types = self.parse_event_types(attributes)

            # Parse properties
            props = []
            prop_pattern = r'\[\s*WmiDataId\s*\(\s*(\d+)\s*\)(.*?)\]\s*(\w+)\s+(\w+)\s*;'

            for prop in re.finditer(prop_pattern, body, re.DOTALL):
                props.append(self.parse_property(*prop.groups()))

            self.classes.append({
                'name': name,
                'base': base,
                'guid': guid.group(1) if guid else None,
                'version': version.group(1) if version else None,
                'event_types': event_types,
                'props': props
            })

    def parse_property(self, wmi_id, qualifiers, type_name, name):
        """Enhanced property parser handling all MOF qualifiers"""
        in_type = TYPE_MAP.get(type_name, 'TDH_INTYPE_NULL')
        out_type = None
        array_size = None

        # Handle string types
        if type_name == 'string':
            # Default to ANSI string unless format("w") is specified
            base_type = (
                'TDH_INTYPE_UNICODESTRING'
                if 'format("w")' in qualifiers
                else 'TDH_INTYPE_ANSISTRING'
            )
            in_type = base_type

            # Check StringTermination qualifier
            if 'StringTermination("Counted")' in qualifiers:
                in_type = 'TDH_INTYPE_COUNTEDSTRING'
            elif 'StringTermination("ReverseCounted")' in qualifiers:
                in_type = 'TDH_INTYPE_REVERSEDCOUNTEDSTRING'
                # NotCounted means the string takes up all remaining space
                in_type = base_type  # Use base string type (ANSI/Unicode)
            else:
                # Default or explicit NullTerminated
                in_type = base_type  # Use base string type (ANSI/Unicode)

        # Handle char16 with format("s")
        elif type_name == 'char16' and 'format("s")' in qualifiers:
            in_type = 'TDH_INTYPE_UNICODECHAR'
            out_type = 'TDH_OUTTYPE_STRING'

        # Handle format qualifier
        fmt_match = re.search(r'format\s*\(\s*"(\w)"\s*\)', qualifiers)
        if fmt_match and fmt_match.group(1) in FORMAT_MAP:
            out_type = FORMAT_MAP[fmt_match.group(1)]

        # Handle extension qualifier
        ext_match = re.search(r'extension\s*\(\s*"(\w+)"\s*\)', qualifiers)
        if ext_match and ext_match.group(1) in EXTENSION_MAP:
            in_type, ext_out_type = EXTENSION_MAP[ext_match.group(1)]
            if ext_out_type:  # Extension output type overrides format
                out_type = ext_out_type

        # Handle pointer qualifier
        if 'pointer' in qualifiers.lower() or 'pointertype' in qualifiers.lower():
            in_type = 'TDH_INTYPE_POINTER'

        # Handle array sizes
        size_match = re.search(r'WmiSizeIs\s*\(\s*"(\w+)"\s*\)', qualifiers)
        if size_match:
            array_size = size_match.group(1)
        else:
            max_match = re.search(r'MAX\s*\(\s*(\d+)\s*\)', qualifiers)
            if max_match:
                array_size = max_match.group(1)

        # Handle bitmap/values
        if 'bitmap' in qualifiers.lower():
            out_type = 'TDH_OUTTYPE_BITMAP'

        return {
            'id': wmi_id,
            'name': name,
            'in_type': in_type,
            'out_type': out_type,
            'array_size': array_size
        }

    def parse_event_types(self, attributes):
        """Parse event types from MOF class attributes"""
        # Try array format first: EventType{1, 2, 3}
        array_match = re.search(r'EventType\s*{\s*([\d\s,]+)\s*}', attributes)
        if array_match:
            return [int(x.strip()) for x in array_match.group(1).split(',') if x.strip()]

        # Try single format: EventType(1)
        single_match = re.search(r'EventType\s*\((\d+)\)', attributes)
        if single_match:
            return [int(single_match.group(1))]

        return []

    def generate(self):
        with open(self.output_file, 'w') as f:
            # Write header
            self.write_header(f)

            # Write class definitions
            for cls in self.classes:
                self.write_class(f, cls)

            # Write registration code
            f.write('''
func init() {
    mofClasses := GlobalMofRegistry
''')
            for cls in self.classes:
                var_name = cls['name'][0].lower() + cls['name'][1:]
                f.write(f'    mofClasses.Register({var_name})\n')
            f.write('}\n')

    def write_class(self, f, cls):
        var_name = cls['name'][0].lower() + cls['name'][1:]
        f.write(f'// {cls["name"]} class definition\n')
        f.write(f'var {var_name} = &MofClassDef{{\n')
        f.write(f'    Name: "{cls["name"]}",\n')

        if cls['name'] == 'MSNT_SystemTrace':
            # Special handling for root class
            f.write(f'    GUID: *MustParseGUID("{cls["guid"]}"),\n')
        elif cls['guid']:
            # Base class with GUID
            f.write(f'    GUID: *MustParseGUID("{cls["guid"]}"),\n')
            f.write(f'    Version: {cls["version"]},\n')  # Base class must have version
        elif cls['base']:
            # Child class
            base_var = cls['base'][0].lower() + cls['base'][1:]
            f.write(f'    Base: "{cls["base"]}",\n')
            f.write(f'    GUID: {base_var}.GUID,\n')
            if cls['version'] is not None:
                # Use child's explicit version if defined
                f.write(f'    Version: {cls["version"]},\n')
            else:
                # Inherit version from base class
                f.write(f'    Version: {base_var}.Version,\n')

        if cls['event_types']:
            events = [str(x) for x in cls['event_types']]
            f.write(f'    EventTypes: []uint8{{{", ".join(events)}}},\n')

        if cls['props']:
            f.write('    Properties: []MofPropertyDef{\n')
            for prop in cls['props']:
                line = f'        {{ID: {prop["id"]}, Name: "{prop["name"]}", InType: {prop["in_type"]}'
                if prop['out_type']:
                    line += f', OutType: {prop["out_type"]}'
                if prop['array_size']:
                    line += f', ArraySize: "{prop["array_size"]}"'
                line += '},\n'
                f.write(line)
            f.write('    },\n')

        f.write('}\n\n')

def main():
    generator = MofGenerator('WindowsKernelTrace.mof', '..\\beta_etw_mof_defs_generated.go')
    generator.parse_mof()
    generator.generate()

if __name__ == '__main__':
    main()